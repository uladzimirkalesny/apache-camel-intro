Apache Camel:
Ядром Apache Camel является routing-движок, или по другому routing-engine builder.

Camel’s message model:
В Camel есть две абстракции для модели сообщений:
org.apache.camel.Message - объект, который хранит данные и маршрутизируется в Camel
org.apache.camel.Exchange - абстракция для обмена сообщений. Exchange имеет как входное сообщение так и выходное в качестве ответа

Message - передаются в одном направлении(one direction) от Sender к Receiver
	Sender ----->  Message  -----> Receiver
Message имеют тело(body)-payload, заголовки(headers), необязательные вложения (optional attachments)
Сообщения однозначно идентифицируются с помощью идентификатора типа java.lang.String. 
Уникальность идентификатора обеспечивается и гарантируется создателем сообщения, зависит от протокола и не имеет гарантированного формата. 
Для протоколов, которые не определяют уникальную схему идентификации сообщений, Camel использует свой собственный генератор UID.

Заголовки - это значения, связанные с сообщением, такие как идентификаторы отправителя, подсказки о кодировке содержимого, информация об аутентификации и т. д.
Заголовки - это пары имя-значение; имя является уникальной строкой без учета регистра, а значение имеет тип java.lang.Object.
Заголовки хранятся в виде map в сообщении

Сообщение также может иметь дополнительные вложения, которые обычно используются для веб-службы и компонентов электронной почты.

Body типа java.lang.Object. Когда отправитель и получатель используют разные форматы тела, Camel предоставляет ряд механизмов для преобразования данных в 
приемлемый формат, и во многих случаях преобразование происходит автоматически с помощью преобразователей типов за кулисами.

Message также имеют флаг ошибки. Некоторые протоколы и спецификации, такие как WSDL и JBI, различают выходные сообщения и сообщения об ошибках. 
Они оба являются действительными ответами на вызов операции, но последний указывает на неудачный результат. 
Как правило, ошибки не обрабатываются инфраструктурой интеграции. 
Они являются частью договора между клиентом и сервером и обрабатываются на уровне приложения.


Exchange - В Camel является контейнером сообщений во время routing.
Exchange предоставляет поддержку различных типов взаимодействий между системами, называемых шаблоны обмена сообщениями (MEP)
MEP используются для разграничения стилей обмена сообщениями в one-way и request-response запросах. 
Exchange Camel содержит свойство pattern, которое может быть:
	InOnly - one-way сообщение (также известное как Event message) - JMS message
	InOut — request-response message - Http-based 
Exchange состоит из:
	- Exchange ID - Уникальный id, который идентифицирует exchange. Camel сгенерирует уникальный id по умолчанию, если вы его не указали явно.
	- MEP - Шаблон, который обозначает, используете ли вы стиль сообщений InOnly или InOut. Когда шаблон InOnly, обмен содержит входящее сообщение. 
Для InOut также существует исходящее сообщение, которое содержит ответное сообщение
	- Exception - если в любой момент во время маршрутизации возникает ошибка, в поле исключения будет установлено исключение.
	- Properties - аналогично с headers, но они сохраняются в течение всего обмена. Properties используются для хранения информации глобального уровня, 
тогда как заголовки сообщений относятся к конкретному сообщению. Camel добавляет различные properties к exchange во время routing.
Developer может извлекать, сохранять properties.
	- In message - Это входное сообщение, которое является обязательным. Содердит request message.
	- Out message - это необязательное сообщение, которое существует только если MEP имеет значение InOut.
	

Сamel Architecture:
Routing engine (Механизм маршрутизации) использует routes в качестве спецификаций для маршрутизации messages.
Routes определяются с использованием одного из доменных языков Camel (DSL)
Processors(Процессоры) используются для преобразования и управления сообщениями во время маршрутизации, а также для реализации всех 
шаблонов EIP, имеющих соответствующие ключевые слова на языках DSL. 
Components (Компоненты) являются точками расширения в Camel для добавления подключения к другим системам. 
Чтобы представить эти системы остальной части Camel, компоненты предоставляют интерфейс конечной точки.


Camel concepts:
CamelContext - является средой выполнения Camel, своего рода контейнер, который объединяет все части.
CamelContext предоставляет доступ ко многим полезным службам, наиболее заметными из которых являются: components, type converters, a registry,
endpoints, routes, data formats, and languages.

Components - Содержит используемые компоненты. Camel способен загружать компоненты на лету либо путем автоматического обнаружения на пути к классам, либо при активации нового пакета в контейнере OSGi.
Endpoints - Содержит конечные точки, которые были созданы
Routes - Содержит маршруты, которые были добавлены.
Type converters - Содержит загруженные конвертеры типов. Camel имеет механизм, который позволяет вручную или автоматически конвертировать из одного типа в другой
Data formats - Содержит загруженные форматы данных
Registry - Содержит реестр, который позволяет вам искать бины. По умолчанию это будет реестр JNDI. Если вы используете Camel из Spring, это будет Spring ApplicationContext. 
Это также может быть реестр OSGi, если вы используете Camel в контейнере OSGi
Languages - Содержит загруженные языки. Camel позволяет использовать много разных языков для создания выражений.


ROUTING ENGINE:
Routing Engine Camel - это то, что фактически перемещает message под капотом. Этот механизм не доступен для разработчика, но вы должны знать, что он есть и что он выполняет всю тяжелую работу, обеспечивая правильную маршрутизацию сообщений.

Routes:
Routes являются основной абстракцией для Camel. Самый простой способ определить route - это цепочка processors.
Путем отделения клиентов от серверов и производителей от потребителей routes могут:
	- Динамически решить, какой сервер будет вызывать клиент
	- Предоставиь гибкий способ добавить дополнительную обработку
	- Разрешить клиентам и серверам разрабатываться независимо
	- Разрешить для клиентов серверов быть заглушенным (используя ложные показания) для целей тестирования
	- Внедрение лучших методов проектирования путем подключения разрозненных систем, которые хорошо выполняют одну задачу
	- Расширять возможности и функциональность некоторых систем (таких как брокеры сообщений и ESB)
Каждый route в Camel имеет уникальный идентификатор, который используется для регистрации, отладки, мониторинга, запуска и остановки routes.
Routes также имеют ровно один источник ввода для сообщений, поэтому они эффективно привязаны к endpoint ввода.

DOMAIN-SPECIFIC LANGUAGE (DSL)
Чтобы связать processors и endpoints вместе для формирования routes, Camel определяет DSL. 
Термин DSL здесь используется немного свободно. В Camel DSL означает свободный API Java, который содержит методы, названные для терминов EIP.
from("file:data/inbox")
	.filter().xpath("/order[not(@test)]")
	.to("jms:queue:order")
Сообщения направляются в фильтр EIP, который будет использовать предикат XPath, чтобы проверить, является ли сообщение тестовым заказом или нет.
Если сообщение проходит тест, оно пересылается в конечную точку JMS. Сообщения, не прошедшие проверку фильтра, будут удалены.

SPRING DSL:
<route>
	<from uri="file:data/inbox"/>
	<filter>
		<xpath>/order[not(@test)]</xpath>
		<to uri="jms:queue:order"/>
	</filter>
</route>

DSL обеспечивают хорошую абстракцию для пользователей Camel для создания приложений. Однако под капотом route фактически состоит из graph processors.

PROCESSOR
Processor - это основная концепция Camel, представляющая node, способный использовать, создавать или изменять входящий exchange.
Во время routing обмены передаются от одного процессора к другому; таким образом, вы можете думать о маршруте как о graph, 
имеющем специализированные процессоры в качестве nodes, и линиях, которые соединяют выход одного процессора с входом другого. 
Многие из процессоров являются реализациями EIP, но можно легко реализовать свой собственный процессор и вставить его в маршрут.

COMPONENT
Component - являются основной точкой расширения в Camel. 
На сегодняшний день в экосистеме Camel насчитывается более 80 компонентов, которые функционируют от data transports до DSL, форматов данных и т. д.
С точки зрения программирования, компоненты довольно просты: они связаны с именем, используемым в URI, и действуют как фабрика endpoits. 
Например, FileComponent ссылается на файл в URI и создает FileEndpoints. Endpoint, возможно, является еще более фундаментальной концепцией в Camel

ENDPOINT
Endpoint - это абстракция Camel, которая моделирует конец канала, через который система может отправлять или получать messages.
В Camel endpoints настраиваются, используя URI, такие как file:data/inbox?Delay=5000, и вы также ссылаетесь на endpoints таким образом. 
Во время выполнения, Camel будет искать endpoint на основе записи URI.

file:data/inbox?Delay=5000 - Endpoint состоит из:
file - scheme - тип конечной точки. В этом случае схема file выбирает FileComponent. 
Затем FileComponent работает как фабрика, создающая FileEndpoint на основе оставшихся частей URI.
data/inbox - context path - cообщает FileComponent, что начальная папка - data/inbox.
Delay=5000 - options - опция - указывает, что файлы должны опрашиваться с интервалом в 5 секунд.

Endpoint действует как фабрика для создания consumers и producers, способных принимать и отправлять сообщения определенной endpoint.


PRODUCER
Producer - является абстракция Camel, которая относится к объекту, способному создавать и отправлять message endpoint'у.
Когда message необходимо отправить endpoint'у, producer создаст exchange и заполнит его данными, совместимыми с этой конкретным endpoint. 
Например, FileProducer запишет message body в файл.
JmsProducer, с другой стороны, преобразует message Camel в message javax.jms.Message перед отправкой его в пункт назначения JMS. 
Это важная особенность Camel, потому что она скрывает сложность взаимодействия с определенными транспортными средствами. 
Все, что вам нужно сделать, это направить message в endpoint, и producer проделывает тяжелую работу.


CONSUMER
Consumer - это service, который получает messages, произведенные producer, упаковывает их в exchange и отправляет их для обработки. 
Потребители являются источником exchange в Camel.
В Camel есть два вида потребителей: потребители, Event-Driven Consumer, и Polling Consumers.

EVENT-DRIVEN CONSUMER
Этот тип потребителей в основном связан с клиент-серверными архитектурами и веб-сервисами. 
Он также упоминается как асинхронный приемник в мире EIP. 
Потребитель, управляемый событиями, прослушивает определенный канал обмена сообщениями, обычно порт TCP/IP или очередь JMS, и ждет, 
пока клиент отправит ему сообщения. Когда приходит сообщение, потребитель просыпается и принимает сообщение для обработки.

POLLING CONSUMER
В отличие от потребителя, управляемого событиями, потребитель опроса активно отправляет и извлекает сообщения из определенного источника, 
такого как FTP-сервер. Потребитель опроса также известен как синхронный получатель в EIP lingo, потому что он не будет запрашивать 
больше сообщений, пока не завершит обработку текущего сообщения. Распространенным видом потребителя опроса является запланированный 
потребитель опроса, который опрашивает с запланированным интервалом. 
Файлы, FTP и электронная почта все используют запланированные опросы потребителей.



Routing with Camel


В Apache Camel routing является более общей концепцией, которая определяется как пошаговое движение сообщения, которое исходит от endpoint в роли consumer.
Consumer может получать message от внешней службы, опрашивать message в какой-либо системе или даже создавать само message.
